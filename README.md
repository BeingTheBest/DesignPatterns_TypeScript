## 标题：
* 前端开发者如何学习设计模式
* 设计模式的来龙去脉
* TypeScript版设计模式


## 主要参考文献：
* 《Java设计模式：23种设计模式全面解析》,http://c.biancheng.net/design_pattern/
* 《设计模式|菜鸟教程》,http://www.runoob.com/design-pattern/design-pattern-tutorial.html
* 《刘伟技术博客》,https://blog.csdn.net/lovelion
* 刘伟,《设计模式Java版》,https://gof.quanke.name/
* 曾探,《JavaScript设计模式与开发实践》,北京：人民邮电出版社,2015.5
* Addy Osmani,《JavaScript设计模式》,徐涛 译,北京：人民邮电出版社,2013.6
* codeTao,《23种设计模式全解析》,http://www.cnblogs.com/geek6/p/3951677.html
* me115,《图说设计模式》,https://design-patterns.readthedocs.io/zh_CN/latest/index.html
* vczh,《为什么我们需要学习（设计）模式》,https://zhuanlan.zhihu.com/p/19835717
* 杨博,《代码耦合是怎么回事呢？》,https://www.zhihu.com/question/21386172/answer/54476702
* 知乎问题,《为何大量设计模式在动态语言中不适用》,https://www.zhihu.com/question/63734103
* Mingqi,《Spring IoC有什么好处呢？》,https://www.zhihu.com/question/23277575/answer/169698662
* 阮一峰,《ECMAScript 6 入门》,http://es6.ruanyifeng.com/
* 萧萧,《设计模式在实际开发中用的多吗》,https://www.zhihu.com/question/29477933/answer/586378235
* DD菜,《浅析Typescript设计模式》,https://zhuanlan.zhihu.com/p/43283016


## 前言：
* 背景：
  前端开发者普遍缺乏设计模式相关知识，但网上相关资料基本都是基于java或c#，不利于前端学习。部分基于js的设计模式书籍往往又只是单单通过动态语言js来实现，这样根本是无法真正理解设计模式的，因为经典23种设计模式是基于静态语言设计的。又要前端熟悉的语言，又要是静态语言，所以我选择使用TypeScript语言来实现设计模式。
* 关于TypeScript：
  TypeScript简称ts。ts基本就等于es6+类型系统，前端上手比较简单。我的学习经验是先看文档整体了解基本概念，重点学习类及其下属概念；再在github上搜索中小型ts项目，看看人家怎么写的，并将人家代码上看不懂的地方（语法方面）回头查阅文档，ts的新概念不多，查过几回就清楚了；最后就是自己动手写一些小游戏，如打飞机、像素鸟等，不推荐用web项目练习，因为web开发通常都是割裂的逻辑，不适合想象成一个整体世界；而游戏则是一个自然而然的世界，在这个世界里，我们将一切事物都想象成一个个的对象，这就很适合我们ts用面向对象的范式就行开发了。 在开完两个项目后，你极有可能就会跟当年的我一样认为面向对象开发不过就是class嘛。直到我看到“面向接口编程”这个概念时，才明白仅仅之前的所谓的面向对象并不纯正，或者还是只能称为面向过程开发，只有class + interface才是真正的面向对象，并由此牵出设计原则、设计模式、控制反转、依赖注入、IoC容器、反射等等一系列后端开发中的重要概念。项目首先将会带领读者系统了解这些概念，并理清他们之间的关系，以为学习设计模式打好基础。
* 项目内容：
```
  ①帮助缺乏经验的前端开发者了解设计模式的来龙去脉，并真正了解设计原则和设计模式，以及拓展到后端知识面。
  ②实现TypeScript版设计模式代码。
  ③实现Java/JavaScript版设计模式代码部分补充。
```
* 理解有误处欢迎指出。


## 什么是设计模式？
* 狭义的设计模式：指的是GoF四人组在《Design Patterns: Elements of Reusable Object-Oriented Software》一书中提出的23种设计模式。
* 广义的设计模式：最早的设计模式是美国著名建筑大师克里斯托夫* 亚历山大在他的著作《建筑模式语言：城镇、建筑、构造》中描述了一些常见的建筑设计问题，并提出了253种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。后来软件界也开始论坛设计模式的话题，因为这也是类似的。所以设计模式指的是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，是可以反复使用的。


## 为什么要学习设计模式？
```
  在弄清楚这个问题之前，我们先思考什么才是高质量的程序？高质量程序的特点：开发周期短、代码无bug、代码性能高、代码够健壮、代码易阅读、代码易扩展、代码易重用。那我们如何开发出高质量程序呢？答案就是遵守前人总结的7大开发原则：①开闭原则：总纲，要对扩展开放，对修改关闭②里氏替换原则：不要破坏继承体系③依赖倒置原则：要面向接口编程④单一职责原则：实现类要职责单一⑤接口隔离原则：在设计接口的时候要精简单一⑥迪米特法则：要降低耦合度⑦合成复用原则：要优先使用组合或者聚合关系复用，少用继承关系复用。
  好的程序需要靠7大设计原则完成，但是由于语言的设计缺陷导致程序需要按照一定复杂度的步骤去实现这些设计原则，而这些步骤通常都是固定的，就像武功中的套路招式一样，这些招式也就是设计模式。也就是说23种设计模式就是7大设计原则在某些语言的具体实现之一，每个设计模式的背后我们都能找到其依靠的一种或多种设计原则。换句话说就是，只要我们写代码遵循设计原则，代码就会自然而然变成了设计模式，这也在王垠的《解密“设计模式”》中得到证明。
  虽然学好设计原则后，按道理人人都自然而然地会了设计模式。但由于实现问题的复杂性，导致不可能同时满足所有的设计原则，甚至要违背部分设计原则，这里就会有一个最佳实践的问题了。而设计模式就为解决特定问题提供了解决方案，以至于学习了设计模式后，在遇到特定问题时，我们脑子很容易知道如何高效解决这类问题。
  回到问题，为什么要学习设计模式？学习设计模式的根本目的不是为了记住招式，而是为了通过写代码的形式帮助我们更好的理解设计原则，理解了设计原则，就可以写出高质量的程序了。另外，对于缺乏经验的开发者来说，学习设计模式也是学习解决特定场景问题的解决方案，当然这也算是编写高质量程序的一部分啦。
```

## 解耦与高质量程序之间的是什么关系？
* 解耦（低耦合）在某个角度上说属于高质量程序的一个重要体现，但不是全部。高质量程序具体还体现在代码易复用、代码安全稳定、代码层次结构清晰、代码易扩展、代码性能好等等许多细节方面。
* 解耦是一个很模糊的定义，耦合性高低实际上可以用依赖性、正交性、紧凑性3个指标来衡量，具体参考：https://www.zhihu.com/question/21386172/answer/54476702。实际上这3个指标大概分别对应着7大设计原则中的迪米特法则、单一职责原则、接口隔离原则等原则，而7大设计原则也就是高质量软件的编写原则，所以也印证了解耦是属于高质量程序的一部分体现。


## 设计模式补充：
* 设计模式的招式并不是一成不变的，它在不同语言中会有不同的表现，但背后的设计原则都是一样的，例如装饰器模式在java中需要定义抽象构件、抽象装饰，而ts只需一个@即可搞定。牛逼的语言不需要那么多设计模式也能满足设计原则，参考：https://zhuanlan.zhihu.com/p/19835717
* 设计模式在不同语言之间的区别：GoF的《设计模式》一书是针对面向对象语言提炼的技巧，但并不意味着设计模式只能用面向对象语言来写，实际上动态语言也是可以使用设计模式的。例如Java这种静态编译型语言中，无法动态给已存在的对象添加职责，所有一般通过包装类的方式来实现装饰者模式。但是js这种动态解释型语言中，给对象动态添加职责是再简单不过的事情。这就造成了js的装饰者模式不再关注给对象动态添加职责，而是关注于给函数动态添加职责。例如有人模拟js版本的工厂模式，而生硬地把创建对象延迟到子类中。实际上，在java等静态语言中，让子类来“决定”创建何种对象的原因是为了让程序迎合依赖倒置原则。在这些语言中创建对象时，先解开对象类型之间的耦合关系非常重要，这样才有机会在将来让对象表现出多态性。而在js这类类型模糊的语言中，对象多态性是天生的，一个变量既可以指向一个类，又可以随时指向另一个类。js不存在类型耦合的问题，自然也没有刻意去把对象“延迟”到子类创建，也就是说，js实际上是不需要工厂方法模式的。模式的存在首先是为了满足设计原则的。
* 设计模式有时候不能同时满足所有设计原则，但是设计模式通常是一类问题的最佳实践
* 设计模式的合理使用：
</br>  -- 总体来说，使用设计模式的必要性的程度是逐级递增的：应用程序(Application) < 工具包/类库（ToolKit/Library） < 框架(Framework)
</br>  -- 具体来说，我们不必刻意为了设计模式而设计模式，例如我们当前只需要创建一个产品，而未来没有多大可能增加新产品时，我们就用简单工厂模式，而无需为了符合开闭原则而去选择工厂方法模式。引用轮子哥的话：“为了合理的利用设计模式，我们应该明白一个概念，叫做扩展点。扩展点不是天生就有的，而是设计出来的。我们设计一个软件的架构的时候，我们也要同时设计一下哪些地方以后可以改，哪些地方以后不能改。倘若你的设计不能满足现实世界的需要，那你就要重构，把有用的扩展点加进去，把没用的扩展点去除掉。这跟你用不用设计模式没关系，跟你对具体的行业的理解有关系。倘若你设计好了每一个扩展点的位置，那你就可以在每一个扩展点上应用设计模式，你就不需要去想到底这个扩展点要怎么实现他才会真正成为一个扩展点，你只需要按照套路写出来就好了。
* 关于接口和抽象类：实际开发中90%的情况使用接口，因为其简洁、灵活。而抽象类只在既起约束作用又需要复用代码时才使用。
* 设计模式命名：为了他人能快速理解你使用的设计模式，建议参考模式英文名进行命名，例如：建造者模式——xxxBuilder，单例模式——xxxSingleton，适配器模式——xxxAdapter，状态模式——xxxState，策略模式——xxxStratege等等
* 分辨模式的关键是意图而不是结构：在设计模式的学习中，有人经常会发出这样的疑问：代理模式和装饰着模式，策略模式和状态模式，这些模式的类图看起来几乎一模一样，他们到底有什么区别？实际上这种情况是普遍存在的，许多模式的类图看起来都差不多，模式只有放在具体的环境下才有意义。比如我们的手机，用它当电话的时候它就是电话；用它当闹钟的时候它就是闹钟；用它玩游戏的时候他就是游戏机。有很多模式的类图和结构确实很相似，但这不太重要，辨别模式的关键是这个模式出现的场景，以及为我们解决了什么问题。
* 设计模式一直在发展，例如现在逐渐流行起来的模块模式、沙箱模式等，但真正得到人们的认可还需要时间的检验。
* 对设计模式的误解：
</br>  -- 习惯把静态语言的设计模式照搬到动态语言中
</br>  -- 习惯根据模式名称去臆测该模式的一切


# -------------------设计原则--------------------
## 开闭原则：
* 定义：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。
* 解释：
```
  当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。
  为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。
  在软件开发中，一般不把对配置文件的修改认为是对系统源代码的修改。如果一个系统在扩展时只涉及到修改配置文件，而原有的代码没有做任何修改，该系统即可认为是一个符合开闭原则的系统。所以，配置文件+反射技术在java、c#、.net等各类后端语言中大量采用，以实现完全开闭原则。
```
* 开闭原则的实现由里氏替换原则和依赖倒置原则来完成。


## 里氏替换原则：
* 背景：
```
  继承的优点：代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性、提高代码的重用性、子类可以形似父类，但又异于父类、提高代码的可扩展性、提高产品或项目的开放性。
  继承的缺点：继承是侵入性的：只要继承，就必须拥有父类的所有属性和方法、降低代码的灵活性：子类必须拥有父类的属性和方法、增强了耦合性：当父类的常量、变量和方法被修改时，必需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果大片的代码需要重构
  里氏替换原则能够克服继承的缺点。
```
* 定义：子类可以扩展父类的功能，但不能改变父类原有的功能。父类能出现的地方都可以用子类来代替，而且换成子类也不会出现任何错误或异常，而使用者也无需知道是父类还是子类，但反过来则不成立。
* 解释：
  里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。
* 解释：
```
  ①子类必须完全实现父类的抽象方法，但不能覆盖父类的非抽象方法；
  ②子类中可以增加自己特有的方法；
  ③当子类的方法重载父类的方法时，方法的前置条件(即方法的形参)要比父类方法的输入参数要更宽松；
  ④当子类的方法实现父类的抽象方法时，方法的后置条件(即方法的返回值)要比父类更严格。
```
* 解释：
```
  ①这个原则使得继承复用成为了可能， 只有当子类可以替换掉父类， 软件单位的功能不受到影响时，父类才能真正被复用， 而子类也能够在父类的基础上增加新的行为。正是由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展、不然还谈什么扩展开放， 修改关闭呢。
  ②LSP的原定义比较复杂，我们一般对里氏替换原则 LSP的解释为：子类对象能够替换父类对象，而程序逻辑不变。
```
* 解释：
```
  里氏替换原则有至少以下两种含义：
  ①里氏替换原则是针对继承而言的，如果继承是为了实现代码重用，也就是为了共享方法，那么共享的父类方法就应该保持不变，不能被子类重新定义。子类只能通过新添加方法来扩展功能，父类和子类都可以实例化，而子类继承的方法和父类是一样的，父类调用方法的地方，子类也可以调用同一个继承得来的，逻辑和父类一致的方法，这时用子类对象将父类对象替换掉时，当然逻辑一致，相安无事。
  ②如果继承的目的是为了多态，而多态的前提就是子类覆盖并重新定义父类的方法，为了符合LSP，我们应该将父类定义为抽象类，并定义抽象方法，让子类重新定义这些方法，当父类是抽象类时，父类就是不能实例化，所以也不存在可实例化的父类对象在程序里。也就不存在子类替换父类实例（根本不存在父类实例了）时逻辑不一致的可能。
  不符合LSP的最常见的情况是，父类和子类都是可实例化的非抽象类，且父类的方法被子类重新定义，这一类的实现继承会造成父类和子类间的强耦合，也就是实际上并不相关的属性和方法牵强附会在一起，不利于程序扩展和维护。
  如何符合LSP？总结一句话 —— 就是尽量不要从可实例化的父类中继承，而是要使用基于抽象类和接口的继承。
```
* 里氏代换原则和依赖倒置原则一样，是开闭原则的具体实现手段之一。


## 依赖倒置原则：
* 定义：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。
* 解释：
```
  高层模块不应该直接依赖于底层模块的具体实现，而应该依赖于底层的抽象。换言之，模块间的依赖是通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。
  接口和抽象类不应该依赖于实现类，而实现类依赖接口或抽象类。这一点其实不用多说，很好理解，“面向接口编程”思想正是这点的最好体现。
```
* 解释：
  常规我们认为上层模块应该依赖下层，但是这也有个问题就是，下层变动将导致“牵一发动全身”。依赖倒置就是反常规思维，将原本的高层建筑依赖底层建筑“倒置”过来，变成底层建筑依赖高层建筑。高层建筑决定需要什么，底层去实现这样的需求，但是高层并不用管底层是怎么实现的。这样就不会出现前面的“牵一发动全身”的情况。当然，严格的来说上层不应该依赖下层，而依赖自身接口，通过注入的方式依赖其他接口。
* 控制反转（Inversion of Control）：就是依赖倒置原则的一种代码设计的思路。具体采用的实现方法就是所谓的依赖注入（Dependency Injection）。
* 控制反转容器(IoC Container)：，因为采用了依赖注入，在初始化的过程中就不可避免的会写大量的new，并且还要要管理各个对象之间依赖关系，所以这里使用工厂方法还是比较麻烦。而IoC容器就解决以上2个问题。这个容器可以自动对你的代码进行初始化，你只需要维护一个Configuration（可以是xml可以是一段代码），而不用每次初始化一实例都要亲手去写那一大段初始化的代码。另外一个好处是：我们在创建实例的时候不需要了解其中的依赖细节。
* ts实现IoC容器：
</br>  -- 《使用Typescript实现依赖注入（DI）》：https://blog.csdn.net/HaoDaWang/article/details/79776021
</br>  -- 《细数Javascript技术栈中的四种依赖注入》：http://www.cnblogs.com/front-end-ralph/p/5208045.html
* java的反射机制：
</br>  -- 类也是对象，类是java.lang.Class类的实例对象
</br>  -- 编译时刻加载类是静态加载类，运行时刻加载类是动态加载类。new创建对象是静态加载类，在编译时刻就要加载所有可能用到的类，这样导致某一个类（的类型）出现问题，其他所有类都将无法使用（无法通过编译）。通过动态加载类可以解决这个问题。动态加载的方法，即通过类的类类型创建该类的对象，示例：Class c=Class.forName(args[0]);c.newInstance();
</br>  -- 获取类的方法信息，代码示例：Class c=obj.getClass();Method[] ms=c.getMethods();//参数列表获取省略
</br>  -- 获取类的成员变量信息，代码示例：Class c=obj.getClass();Field[] fs=c.getFields();
</br>  -- 获取类的构造方法信息信息，代码示例：Class c=obj.getClass();Constructor[] cs=c.getConstructors();//参数列表获取省略
</br>  -- 方法的反射，操作步骤：①根据方法的名称和参数列表获取唯一的方法；②拿到方法后，method.invoke(对象,参数列表)。
</br>  -- 反射的操作都是编译成字节码以后的操作
</br>  -- java中集合的泛型是防止错误输入的，只在编译阶段有效，绕过编译就无效了。（其实typescirpt也是这样的，类型检查只发生在编译时）
</br>  -- 因为反射的操作是编译后的，所以不存在类型检查问题了
</br>  -- 小结：Java反射机制允许程序在运行时透过Reflection APIs取得任意一个已知名称的class的内部信息，包括modifiers（如public、static等）、superclass（如Object）、实现的interfaces（如Serializable）、fields（属性）和methods（方法）（但不包括methods定义），可于运行时改变fields的内容，也可调用methods.
</br>  -- 配置文件+反射机制实现开闭原则：在引入配置文件和反射机制后，需要更换或增加新的具体类将变得很简单，只需增加新的具体类并修改配置文件即可，无须对现有类库和客户端代码进行任何修改，完全符合开闭原则。在很多设计模式中都可以通过引入配置文件和反射机制来对客户端代码进行改进，如在抽象工厂模式中可以将具体工厂类类名存储在配置文件中，在适配器模式中可以将适配器类类名存储在配置文件中，在策略模式中可以将具体策略类类名存储在配置文件中等等。通过对代码的改进，可以让系统具有更好的扩展性和灵活性，更加满足各种面向对象设计原则的要求。
* ts的反射机制实现：
</br>  -- ES6中新增了新的api：Reflect。Reflect能够获取到类中的成员变量和方法，但是无法获取究竟有哪些装饰器添加到这个类/方法上。为了获取到装饰器，Reflect Metadata 应运而生。Reflect Metadata 是 ES7 的一个提案，它主要用来在声明的时候添加和读取元数据。
</br>  -- 《详解学习Reflect Metadata》：https://www.jianshu.com/p/2abb2469bcbb
</br>  -- 《TS从装饰器到注解到元编程》：https://www.jianshu.com/p/e280d916495b
* 依赖注入的三种写法：
```
  ①构造函数传递依赖对象：
public interface IDriver{
    //是司机就应该会驾驶汽车
    public void drive();
}
public class Driver implements IDriver{
    private ICar car;
    //构造函数注入
    public Driver(ICar _car){
        this.car = _car;
    }   
    //司机的主要职责就是驾驶汽车
    public void drive(){
        this.car.run();
    }
}
  ②Setter方法传递依赖对象：
public interface IDriver {
    //车辆型号
    public void setCar(ICar car);
    //是司机就应该会驾驶汽车
    public void drive();
}
public class Driver implements IDriver{
    private ICar car;
    public void setCar(ICar car){
        this.car = car;
    }
    //司机的主要职责就是驾驶汽车
    public void drive(){
        this.car.run();
    }
}
  ③接口声明依赖对象：
public interface IDriver{
    //是司机就应该会驾驶汽车
    public void drive();
}
public class Driver implements IDriver{
    private ICar car;
    //构造函数注入
    public Driver(ICar _car){
        this.car = _car;
    }   
    //司机的主要职责就是驾驶汽车
    public void drive(){
        this.car.run();
    }
}
```
* 里氏代换原则和依赖倒置原则一样，是开闭原则的具体实现手段之一。
* 最佳实践：
</br>  -- 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备：这是依赖倒置的基本要求，接口和抽象类都是属于抽象的，有了抽象才可能依赖倒置。
</br>  -- 变量的显示类型尽量是接口或者是抽象类：很多书上说变量的类型一定要是接口或者是抽象类，这个有点绝对化了，比如一个工具类，xxxUtils一般是不需要接口或是抽象类的。还有，如果你要使用类的clone方法，就必须使用实现类，这个是JDK提供一个规范。
</br>  -- 任何类都不应该从具体类派生：如果一个项目处于开发状态，确实不应该有从具体类派生出的子类的情况，但这也不是绝对的，因为人都是会犯错误的，有时设计缺陷是在所难免的，因此只要不超过两层的继承都是可以忍受的。特别是做项目维护的同志，基本上可以不考虑这个规则，为什么？维护工作基本上都是做扩展开发，修复行为，通过一个继承关系，覆写一个方法就可以修正一个很大的Bug，何必再要去继承最高的基类呢？
</br>  -- 尽量不要覆写基类的方法：如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会产生一定的影响。
</br>  -- 结合里氏替换原则使用：里氏替换原则要求父类出现的地方子类就能出现，再依赖倒置原则，我们可以得出这样一个通俗的规则： 接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化。
* 文档：
</br>  -- 《Spring IoC有什么好处呢？》：https://www.zhihu.com/question/23277575/answer/169698662
</br>  -- 《依赖倒置原则》：https://www.cnblogs.com/cbf4life/archive/2009/12/15/1624435.html
</br>  -- 《小话设计模式原则之：依赖倒置原则DIP》：https://zhuanlan.zhihu.com/p/24175489


## 单一职责原则：
* 定义：一个类只负责一个功能领域中的相应职责，或者就一个类而言，应该只有一个引起它变化的原因。
* 解释：一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。


## 接口隔离原则：
* 定义：一个类对另一个类的依赖应该建立在最小的接口上，即要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。
* 解释：
</br>  -- 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。
</br>  -- 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。
</br>  -- 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。
</br>  -- 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。


## 迪米特法则：
* 定义：一个软件实体应当尽可能少地与其他实体发生相互作用。
* 解释：
</br>  -- 保证类之间单向依赖（jacksplwxy）
</br>  -- 从依赖者的角度来说，只依赖应该依赖的对象。
</br>  -- 从被依赖者的角度说，只暴露应该暴露的方法。
</br>  -- 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。
</br>  -- 在类的结构设计上，尽量降低类成员的访问权限。
</br>  -- 在类的设计上，优先考虑将一个类设置成不变类。
</br>  -- 在对其他类的引用上，将引用其他对象的次数降到最低。
</br>  -- 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。
</br>  -- 谨慎使用序列化（Serializable）功能。


## 合成复用原则：
* 定义：尽量使用对象组合，而不是继承来达到复用的目的。
* 解释：
```
  在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。
  通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）。
  由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用，相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作；合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。
```


# -------------------设计模式--------------------

## 设计模式的内容：
* 创建型模式（5种）： 
</br>  -- 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
</br>  -- 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
</br>  -- 工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
</br>  -- 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
</br>  -- 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。
* 结构型模式（7种）：
</br>  -- 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
</br>  -- 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
</br>  -- 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。
</br>  -- 装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。
</br>  -- 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
</br>  -- 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
</br>  -- 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。
* 行为型模式（11种）：
</br>  -- 模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
</br>  -- 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
</br>  -- 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
</br>  -- 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
</br>  -- 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
</br>  -- 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
</br>  -- 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
</br>  -- 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
</br>  -- 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
</br>  -- 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
</br>  -- 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。


## 单例模式
* 定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。
* 解释：在有些系统中，为了节省内存资源、保证数据内容的一致性，对某些类要求只能创建一个实例，这就是所谓的单例模式。
* 场景：
</br>  -- 在每一届任期内，美国的总统只有一人
</br>  -- 微信小程序中的toast，无论你创建多少次，它永远都是同一个
</br>  -- Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。
* 优点：
* 缺点：
* ts通用代码：
* ts实例代码：
* js通用代码：

## 工厂方法模式：
* 定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。
* 解释：我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”（https://baike.baidu.com/item/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/9852061?fr=aladdin），它不属于 GoF 的 23 种经典设计模式，它的缺点是增加新产品时会违背“开闭原则”。“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。
* 场景：
</br>  -- 有很多种类的畜牧场，如养马场用于养马，养牛场用于养牛，所以该实例用工厂方法模式比较适合
</br>  -- 有一间塑料加工厂（仅生产A类产品）；随着客户需求的变化，客户需要生产B类产品；
</br>  -- 设计一个程序来读取各种不同类型的图片格式，针对每一种图片格式都设计一个图片读取器，如GIF图片读取器用于读取GIF格式的图片、JPG图片读取器用于读取JPG格式的图片。需充分考虑系统的灵活性和可扩展性。
* 优点：
* 缺点：
* ts通用代码：
* ts实例代码：
* js通用代码：


## 抽象工厂模式：
* 定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。
* 解释：抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。同种类称为同等级，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等，抽象工厂模式将考虑多等级产品的生产
* 场景：
</br>  -- 农场中除了像畜牧场一样可以养动物，还可以培养植物，如养马、养牛、种菜、种水果等，由于种类复杂，建议用抽象工厂模式来实现
</br>  -- 参加聚会时，需要有两套或多套衣服，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况，在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用OO的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。
</br>  -- 某软件公司欲推出一款新的手机游戏软件，该软件能够支持Symbian、Android和Windows Mobile等多个智能手机操作系统平台，针对不同的手机操作系统，该游戏软件提供了不同的游戏操作控制(OperationController)类和游戏界面控制(InterfaceController)类，并提供相应的工厂类来封装这些类的初始化过程。软件要求具有较好的扩展性以支持新的操作系统平台，为了满足上述需求，可采用抽象工厂模式对其进行设计。
* 优点：
* 缺点：
* ts通用代码：
* ts实例代码：
* js通用代码：

## 建造者模式：
* 定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。
* 解释：它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。常用于创建复杂对象（多个部件组成）时，并且复杂对象有更换其部件需求时
* 场景：
</br>  -- 《实况足球10》中的人物创建器，可以对球员更换不同的发型、脸型、嘴型、装饰等。
</br>  -- 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"，该套餐就是一个复杂对象。
</br>  -- 腾讯视频播放器：该播放软件提供多种界面显示模式，如完整模式、精简模式、记忆模式、网络模式等。在不同的显示模式下主界面的组成元素有所差异，如在完整模式下将显示菜单、播放列表、主窗口、控制条等，在精简模式下只显示主窗口和控制条，而在记忆模式下将显示主窗口、控制条、收藏列表等。
* 优点：
* 缺点：
* ts通用代码：
* ts实例代码：
* js通用代码：

## 原型模式：
* 定义：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。
* 解释：创建对象的方式有2种，一种是new一个对象，另一种是基于一个对象复制一个对象。由于new有一个初始化过程，有时候这个过程费时费力，代价比较大，所以此时不如直接复制一个对象来得轻松。
* 场景：
</br>  -- 一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。
</br>  -- Windows 操作系统的安装通常较耗时，如果复制就快了很多。
</br>  -- 软件公司在日常办公中有许多公文需要创建、递交和审批，例如《立项建议书》、《项目进展报告》等，为了提高工作效率，在OA系统中为各类公文均创建了模板，用户可以通过这些模板快速创建新的公文，这些公文模板需要统一进行管理，系统根据用户请求的不同生成不同的新公文
* 优点：
* 缺点：
* ts通用代码：
* ts实例代码：
* js通用代码：

## 适配器模式：
* 定义：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
* 解释：对于一个已有的模块，我们想使用它，但是发现它的接口与已有的系统对接不上，但是要重新开发该模块代价又很大，这是可以使用适配器将已有模块和已有系统对接上。
* 场景：
</br>  -- 家用电压为360v，而笔记本电脑电压只能是12v，此时可以通过一个适配器将家庭电压转换为笔记本电压。
</br>  -- 小游戏的运行环境没有BOM和DOM，没有全局的document和window对象。因此当你希望使用DOM API来创建Canvas和Image等元素的时候，会引发错误。此时，微信团队就提供的一个Adapter模块，该模块是对基于浏览器环境的游戏引擎在小游戏运行环境下的一层适配层，使游戏引擎在调用DOM和访问DOM属性时不会产生错误。（https://developers.weixin.qq.com/minigame/dev/tutorial/base/adapter.html）
</br>  -- 某软件公司在很久以前曾开发了一个算法库，里面包含了一些常用的算法，例如排序算法和查找算法，在进行各类软件开发时经常需要重用该算法库中的算法。在为某学校开发教务管理系统时，开发人员发现需要对学生成绩进行排序和查找，该系统的设计人员已经开发了一个成绩操作接口ScoreOperation，在该接口中声明了排序方法sort(int[]) 和查找方法search(int[], int)，为了提高排序和查找的效率，开发人员决定重用算法库中的快速排序算法类QuickSort和二分查找算法类BinarySearch，其中QuickSort的quickSort(int[])方法实现了快速排序，BinarySearch 的binarySearch (int[], int)方法实现了二分查找。由于某些原因，现在某公司开发人员已经找不到该算法库的源代码，无法直接通过复制和粘贴操作来重用其中的代码；部分开发人员已经针对ScoreOperation接口编程，如果再要求对该接口进行修改或要求大家直接使用QuickSort类和BinarySearch类将导致大量代码需要修改。某软件公司开发人员面对这个没有源码的算法库，遇到一个幸福而又烦恼的问题：如何在既不修改现有接口又不需要任何算法库代码的基础上能够实现算法库的重用？最好的实现方法是增加一个类似电源适配器一样的适配器角色，通过适配器来协调这两个原本不兼容的结构。
</br>  -- 某软件公司OA系统需要提供一个加密模块，将用户机密信息（如口令、邮箱等）加密之后再存储在数据库中，系统已经定义好了数据库操作类。为了提高开发效率，现需要重用已有的加密算法，这些算法封装在一些由第三方提供的类中，有些甚至没有源代码。这样可以使用适配器模式设计该加密模块，实现在不修改现有类的基础上重用第三方加密方法。
* 优点：
* 缺点：
* ts通用代码：
* ts实例代码：
* js通用代码：

## 桥接模式：
* 定义：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
* 解释：一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。
* 场景：
</br>  -- 假如我们需要大中小3种型号的画笔，能够绘制12种不同的颜色，如果使用蜡笔，需要准备3×12 = 36支，但如果使用毛笔的话，只需要提供3种型号的毛笔，外加12个颜料盒即可，涉及到的对象个数仅为 3 + 12 = 15，远小于36，却能实现与36支蜡笔同样的功能。如果增加一种新型号的画笔，并且也需要具有12种颜色，对应的蜡笔需增加12支，而毛笔只需增加一支。
</br>  -- 使用egret开发游戏时，由于每款游戏通常需要发布到多个平台上，所以提取出一个统一的接口platform.ts用于开发者获取平台数据信息，http://developer.egret.com/cn/github/egret-docs/Engine2D/minigame/api/index.html
</br>  -- 现欲实现一个图像浏览系统，要求该系统能够显示BMP、JPEG和GIF三种格式的文件，并且能够在Windows和Linux两种操作系统上运行。系统首先将BMP、JPEG和GIF三种格式的文件解析为像素矩阵，然后将像素矩阵显示在屏幕上。系统需具有较好的扩展性以支持新的文件格式和操作系统。为满足上述需求并减少所需生成的子类数目，可采用桥接(Bridge)设计模式进行设计
</br>  -- 欲开发一个数据转换工具，可以将数据库中的数据转换成多种文件格式，例如txt、xml、pdf等格式，同时该工具需要支持多种不同的数据库。可以使用桥接模式对其进行设计。
* 优点：
* 缺点：
* ts通用代码：
* ts实例代码：
* js通用代码：  

## 组合模式：
* 定义：有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。
* 解释：所谓组合模式，其实说的是对象包含对象的问题，通过组合的方式（在对象内部引用对象）来进行布局。组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。同时容器对象与抽象构件类之间还建立一个聚合关联关系，在容器对象中既可以包含叶子，也可以包含容器，以此实现递归组合，形成一个树形结构。如果不使用组合模式，客户端代码将过多地依赖于容器对象复杂的内部实现结构，容器对象内部实现结构的变化将引起客户代码的频繁变化，带来了代码维护复杂、可扩展性差等弊端。
* 场景：
</br>  -- 某软件公司欲开发一个杀毒软件，该软件既可以对某个文件夹杀毒，也可以对某个指定的文件进行杀毒。该杀毒软件还可以根据各类文件的特点，为不同类型的文件提供不同的杀毒方式，例如图像文件和文本文件的杀毒方式就有所差异。可以考虑组合模式作为该杀毒软件的整体框架设计方案。
</br>  -- 某软件公司欲开发一个界面控件库，界面控件分为两大类，一类是单元控件，例如按钮、文本框等，一类是容器控件，例如窗体、中间面板等，可以用组合模式设计该界面控件库。
</br>  -- 某软件公司的内部办公系统某 OA系统中，有一个与公司组织结构对应的树形菜单，行政人员可以给各级单位下发通知，这些单位可以是总公司的一个部门，也可以是一个分公司，还可以是分公司的一个部门。用户只需要选择一个根节点即可实现通知的下发操作，而无须关心具体的实现细节。可以用组合模式设计
* 优点：
* 缺点：
* ts通用代码：
* ts实例代码：
* js通用代码： 

## 装饰器模式：
* 定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式
* 解释：使用装饰器模式能在不改变源代码的基础上，对源代码的功能进行拓展，即为一个类添加一些功能，同时又不希望改变这个类原来的结构。装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。
* 场景：
</br>  -- 某软件公司基于面向对象技术开发了一套图形界面构件库VisualComponent，该构件库提供了大量基本构件，如窗体、文本框、列表框等，由于在使用该构件库时，用户经常要求定制一些特效显示效果，如带滚动条的窗体、带黑色边框的文本框、既带滚动条又带黑色边框的列表框等等，因此经常需要对该构件库进行扩展以增强其功能
</br>  -- 给一个人带上帽子，人没变了，只是多戴了顶帽子
</br>  -- 锦上添花
* 优点：
* 缺点：
* ts通用代码：
* ts实例代码：
* js通用代码：

## 外观模式：
* 定义：是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。
* 解释：外观模式是一种使用频率非常高的结构型设计模式，它通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度，且客户端调用非常方便。外观模式并不给系统增加任何新功能，它仅仅是简化调用接口。
* 场景实例：
</br>  -- 笔记本电脑启动实际包括显示器启动、cpu启动、内存启动、硬盘启动等，而我们只需按下电源键就可以启动这些，无需关心它内部如何运作。
</br>  --  某软件公司欲开发一个可应用于多个软件的文件加密模块，该模块可以对文件中的数据进行加密并将加密之后的数据存储在一个新文件中，具体的流程包括三个部分，分别是读取源文件、加密、保存加密之后的文件，其中，读取文件和保存文件使用流来实现，加密操作通过求模运算实现。这三个操作相对独立，为了实现代码的独立重用，让设计更符合单一职责原则，这三个操作的业务代码封装在三个不同的类中。可使用外观模式设计该文件加密模块。
</br>  -- 浏览器导航页，它能很方便快速跳转常用网页
* 优点：
* 缺点：
* ts通用代码：
* ts实例代码：
* js通用代码：

## 享元模式：
* 定义：运用共享技术来有効地支持大量细粒度对象的复用。它通过共享已经存在的又橡来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。
* 解释：享元模式，换句话说就是共享对象，在某些对象需要重复创建，且最终只需要得到单一结果的情况下使用。因为此种模式是利用先前创建的已有对象，通过某种规则去判断当前所需对象是否可以利用原有对象做相应修改后得到想要的效果
* 场景实例：
</br>  -- 要创建13亿中国人，每人中国人的国籍都为“中国”，即person1.nationality='中国'、person2.nationality='中国'、person3.nationality='中国'等等。享元模式：const Nationality='中国'，person1.nationality=Nationality、person2.nationality=Nationality、person3.nationality=Nationality等等，这样既能极大的节约内存占用。
</br>  -- 围棋的棋子，出了位置和颜色，其他都一样。一样的部分就可以放到缓冲池。
* 补充：对象池技术也是一种性能优化方案，但是对象池的原理是将不要的对象放入对象池中，它的性能优化主要是省去的创建对象时的消耗。对象池的例子：打飞机游戏中，飞机的创建通常来自对象池中。
* 优点：
* 缺点：
* ts通用代码：
* ts实例代码：
* js通用代码：


## 代理模式：
* 定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。
* 解释：当无法直接访问某个对象或访问某个对象存在困难时或访问前需要一定的初始化，这时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，所访问的真实对象与代理对象需要实现相同的接口。根据代理模式的使用目的不同，代理模式又可以分为多种类型，例如保护代理、远程代理、虚拟代理、缓冲代理等，它们应用于不同的场合，满足用户的不同需求。
* 场景：
</br>  -- 代购、房产中介、打官司时找律师等
</br>  -- 虚拟代理：前端常用的图片懒加载功能，在加载图片资源完成之前，先用一张本地图片代替占位
</br>  -- 某软件公司承接了某信息咨询公司的收费商务信息查询系统的开发任务，该系统的基本需求如下：①在进行商务信息查询之前用户需要通过身份验证，只有合法用户才能够使用该查询系统；②在进行商务信息查询时系统需要记录查询日志，以便根据查询次数收取查询费用。该软件公司开发人员已完成了商务信息查询模块的开发任务，现希望能够以一种松耦合的方式向原有系统增加身份验证和日志记录功能，客户端代码可以无区别地对待原始的商务信息查询模块和增加新功能之后的商务信息查询模块，而且可能在将来还要在该信息查询模块中增加一些新的功能。可以使用代理模式设计并实现该收费商务信息查询系统。
</br>  -- 前端请求数据接口时，接口限制了Referer访问。这时前端可以访问自己的后端，后端伪造Referer进行接口请求。此时后端的行为就是代理。
* 优点：
* 缺点：
* ts通用代码：
* ts实例代码：
* js通用代码：




## 模板方法：
* 定义：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
* 解释：在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。
* 实例：
</br>  -- 去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。
</br>  -- 一个人每天会起床、吃饭、做事、睡觉等，其中“做事”的内容每天可能不同。我们把这些规定了流程或格式的实例定义成模板，允许使用者根据自己的需求去更新它
</br>  -- 某软件公司欲为销售管理系统提供一个数据图表显示功能，该功能的实现包括如下几个步骤：①从数据源获取数据；②将数据转换为XML格式；③以某种图表方式显示XML格式的数据。 该功能支持多种数据源和多种图表显示方式，但所有的图表显示操作都基于XML格式的数据，因此可能需要对数据进行转换，如果从数据源获取的数据已经是XML数据则无须转换。
* 优点：
* 缺点：
* ts通用代码：
* ts实例代码：
* js通用代码：


## 策略模式
* 定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。
* 解释：如果使用多重条件转移语句实现，不但使条件语句变得很复杂，而且增加、删除或更换算法要修改原代码，不易维护，违背开闭原则。如果采用策略模式就能很好解决该问题。
* 实例：
</br>  -- 旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略，当然后续想增加坐飞机的方式，策略模式也能很好的支持。
</br>  -- 某软件公司为某电影院开发了一套影院售票系统，在该系统中需要为不同类型的用户提供不同的电影票打折方式，具体打折方案如下：①学生凭学生证可享受票价8折优惠；②年龄在10周岁及以下的儿童可享受每张票减免10元的优惠（原始票价需大于等于20元）；③影院VIP用户除享受票价半价优惠外还可进行积分，积分累计到一定额度可换取电影院赠送的奖品。该系统在将来可能还要根据需要引入新的打折方式。
</br>  -- 白鹭EUI布局中，有基本、水平、垂直、网格共4种自带布局方式，此时想拓展自定义布局方式，只需将自定义好的布局注入即可使用。
* 优点：
* 缺点：
* ts通用代码：
* ts实例代码：
* js通用代码：


## 命令模式：
* 定义：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。
* 解释：将原类的方法转换成具体的命令类，转换过程符合开闭原则，命令类的调用与原类方法的调用之间完全解耦。转换的命令类具有方便储存、传递、调用、管理等好处，所以命令模式还可以轻松实现命令模式、撤销操作、宏命令等能力。
* 场景：
</br>  -- 开关可以控制一些电器的打开和关闭，例如电灯或者排气扇。在购买开关时，我们并不知道它将来到底用于控制什么电器，也就是说，开关与电灯、排气扇并无直接关系，一个开关在安装之后可能用来控制电灯，也可能用来控制排气扇或者其他电器设备。开关与电器之间通过电线建立连接，如果开关打开，则电线通电，电器工作；反之，开关关闭，电线断电，电器停止工作，相同的开关可以通过不同的电线来控制不同的电器。我们可以将开关理解成一个请求的发送者，用户通过它来发送一个“开灯”请求，而电灯是“开灯”请求的最终接收者和处理者，开关和电灯之间并不存在直接耦合关系，它们通过电线连接在一起，使用不同的电线可以连接不同的请求接收者，只需更换一根电线，相同的发送者（开关）即可对应不同的接收者（电器）。
</br>  -- 假设我们正在编写一个用户界面程序，该用户界面上至少有数十个button按钮。因为项目比较复杂，所以我们决定让某个程序员负责绘制这些按钮，而另外一些程序员则负责编写点击按钮后的具体行为，这些行为都被封装在对象里。在大型项目开发中，这是很正常的分工。对于绘制按钮的程序员来说，他完全不知道某个按钮未来将用来做什么，可能用来刷新 菜单界面，也可能用来增加一些子菜单，他只知道点击这个按钮会发生某些事情。那么当完成这个按钮的绘制之后，应该如何给它绑定onclick事件呢？我们很快可以找到在这里运用命令模式的理由：点击了按钮之后，必须向某些负责具体行为的对象发送请求，这些对象就是请求的接收者。但是目前并不知道接收者是什么对象，也不知道接收者究竟会做什么。此时我们需要借助命令对象的帮助，以便解开按钮和负责具体行为对象之间的耦合。
</br>  -- 撤销功能的一种实现方式
</br>  -- 王者荣耀的视频回放，实际就是存储命令记录，再依次执行命令
</br>  -- 操作系统中的日志
* 优点：
* 缺点：
* ts通用代码：
* ts实例代码：
* js通用代码：


## 职责链模式：
* 定义：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。
* 解释：对于多级判断时，我们通常用if else写代码，但这样会导致判断类过大违背单一职责原则，要增减判断或改变判断流程时修改源码违背开闭原则。而职责链模式能解决以上问题。
* 场景：
</br>  -- 在类似“斗地主”这样的纸牌游戏中，某人出牌给他的下家，下家看看手中的牌，如果要不起上家的牌则将出牌请求再转发给他的下家，其下家再进行判断。一个循环下来，如果其他人都要不起该牌，则最初的出牌者可以打出新的牌。在这个过程中，牌作为一个请求沿着一条链在传递，每一位纸牌的玩家都可以处理该请求。在设计模式中，职责链模式就是一种专门用于处理这种请求链式传递的模式。
</br>  -- 某企业的采购审批是分级进行的，即根据采购金额的不同由不同层次的主管人员来审批，主任可以审批5万元以下（不包括5万元）的采购单，副董事长可以审批5万元至10万元（不包括10万元）的采购单，董事长可以审批10万元至50万元（不包括50万元）的采购单，50万元及以上的采购单就需要开董事会讨论决定。
</br>  -- 学校规定学生请假小于或等于 2 天，班主任可以批准；小于或等于 7 天，系主任可以批准；小于或等于 10 天，院长可以批准；其他情况不予批准；
* 优点：
* 缺点：
* ts通用代码：
* ts实例代码：
* js通用代码：

## 状态模式：
* 定义：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。
* 解释：有一个对象，它是有状态的；这个对象在状态不同的时候，行为不一样；这些状态是可以切换的，而非毫无关系。状态模式主要解决的是当控制一个对象状态的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化，这样所带来的好处就是可以大大的增加程序的可维护性与扩展性。
* 优点：
</br>  -- 封装了状态的转换规则，在状态模式中可以将状态的转换代码封装在环境类或者具体状态类中，可以对状态转换代码进行集中管理，而不是分散在一个个业务方法中。
</br>  -- 将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为。
</br>  -- 允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以让我们避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起。
* 实例：https://www.jianshu.com/p/67ad1915fd62
* 使用场景：
</br>  -- 软件公司某开发人员欲开发一个屏幕放大镜工具，其具体功能描述如下：用户单击“放大镜”按钮之后屏幕将放大一倍，再点击一次“放大镜”按钮屏幕再放大一倍，第三次点击该按钮后屏幕将还原到默认大小。
</br>  -- 软件公司欲开发一款纸牌游戏软件，在该游戏软件中用户角色具有入门级(Primary)、熟练级(Secondary)、高手级(Professional)和骨灰级(Final)四种等级，角色的等级与其积分相对应，游戏胜利将增加积分，失败则扣除积分。入门级具有最基本的游戏功能play() ，熟练级增加了游戏胜利积分加倍功能doubleScore()，高手级在熟练级基础上再增加换牌功能changeCards()，骨灰级在高手级基础上再增加偷看他人的牌功能peekCards()。可使用状态模式来设计该系统。
</br>  -- 电梯自定义有4种状态：开、关、走、停止，每个状态执行不同的方法能够改变状态，并且不同的状态只能能执行特定的方法。后续需补充各类异常状态。
* 优点：
* 缺点：
* ts通用代码：
* ts实例代码：
* js通用代码：

## 观察者模式：
* 定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式
* 解释：在前端开发中应用得十分普遍，典型的就是事件监听与触发
* 场景：
</br>  -- 事件监听与触发
</br>  -- 软件公司欲开发一款多人联机对战游戏（类似魔兽世界、星际争霸等游戏），在该游戏中，多个玩家可以加入同一战队组成联盟，当战队中某一成员受到敌人攻击时将给所有其他盟友发送通知，盟友收到通知后将作出响应。
</br>  -- Excel 中的数据与折线图、饼状图、柱状图之间的关系
* 优点：
* 缺点：
* ts通用代码：
* ts实例代码：
* js通用代码：

## 中介者模式：
* 定义：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。
* 解释：多个对象之间存在复杂的交互关系，这种交互关系常常是“网状结构”，而中介者模式就是把这种“网状结构”改为“星形结构”，这样将大大降低它们之间的“耦合性”。中介者模式又叫调停模式，它是迪米特法则的典型应用。
* 场景：
</br>  -- 租房子可以找“房屋中介”，而避免直接与众多房东打交道
</br>  -- QQ聊天程序的“中介者”是QQ服务器
</br>  -- 在 MVC 框架中，控制器（C）就是模型（M）和视图（V）的中介者
</br>  -- 软件公司欲开发一套图形界面类库。该类库需要包含若干预定义的窗格(Pane)对象，例如TextPane、ListPane、GraphicPane等，窗格之间不允许直接引用。基于该类库的应用由一个包含一组窗格的窗口(Window)组成，窗口需要协调窗格之间的行为。可以采用中介者模式设计该系统。
* 优点：
* 缺点：
* ts通用代码：
* ts实例代码：
* js通用代码：

## 迭代器模式：
* 定义：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
* 解释：
</br>  -- 聚合对象拥有两个职责：一是存储数据；二是遍历数据。从依赖性来看，前者是聚合对象的基本职责；而后者既是可变化的，又是可分离的。因此，可以将遍历数据的行为从聚合对象中分离出来，封装在一个被称之为“迭代器”的对象中，由迭代器来提供遍历聚合对象内部数据的行为，这将简化聚合对象的设计，更符合“单一职责原则”的要求。
</br>  -- 迭代器模式：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示。即让用户通过特定的接口访问容器的数据，不需要了解容器内部的数据结构。
* 场景：
</br>  -- Java中的Collection、List、Set、Map都包含了迭代器。
</br>  -- JS中的Array、Map、Set、String、TypedArray、函数的arguments对象、NodeList对象都包含了迭代器。
</br>  -- 由于集合与迭代器的关系太密切了，所以大多数语言在实现集合的时候都给提供了迭代器，并且这些语言提供的集合和迭代器在绝大多数情况下就可以满足我们的需要，所以现在需要我们自己去实践迭代器模式的场景还是比较少见的，我们只需要使用语言中已有的集合和迭代器就可以了。
* 优点：
* 缺点：
* ts通用代码：
* ts实例代码：
* js通用代码：

## 访问者模式：
* 定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。
* 解释：有些被处理的数据元素相对稳定而访问方式多种多样的数据结构，如果用“访问者模式”来处理比较方便。访问者模式能把处理方法从数据结构中分离出来，并可以根据需要增加新的处理方法，且不用修改原来的程序代码与数据结构，这提高了程序的扩展性和灵活性。
* 场景：
</br>  -- 艺术公司利用“铜”可以设计出铜像，利用“纸”可以画出图画；造币公司利用“铜”可以印出铜币，利用“纸”可以印出纸币。对“铜”和“纸”这两种元素，两个公司的处理方法不同，所以该实例用访问者模式来实现比较适合。
</br>  -- 在医生开具处方单后，很多医院都存在如下处理流程：划价人员拿到处方单之后根据药品名称和数量计算总价，药房工作人员根据药品名称和数量准备药品。我们可以将处方单看成一个药品信息的集合，里面包含了一种或多种不同类型的药品信息，不同类型的工作人员（如划价人员和药房工作人员）在操作同一个药品信息集合时将提供不同的处理方式，而且可能还会增加新类型的工作人员来操作处方单。
</br>  -- 软件公司欲为某高校开发一套奖励审批系统，该系统可以实现教师奖励和学生奖励的审批，如果教师发表论文数超过10篇或者学生论文超过2篇可以评选科研奖，如果教师教学反馈分大于等于90分或者学生平均成绩大于等于90分可以评选成绩优秀奖。可使用访问者模式设计该系统，以判断候选人集合中的教师或学生是否符合某种获奖要求。
</br>  -- 软件公司欲为某银行开发一套OA系统，在该OA系统中包含一个员工信息管理子系统，该银行员工包括正式员工和临时工，每周人力资源部和财务部等部门需要对员工数据进行汇总，汇总数据包括员工工作时间、员工工资等。该公司基本制度如下：(1) 正式员工每周工作时间为40小时，不同级别、不同部门的员工每周基本工资不同；如果超过40小时，超出部分按照100元/小时作为加班费；如果少于40小时，所缺时间按照请假处理，请假所扣工资以80元/小时计算，直到基本工资扣除到零为止。除了记录实际工作时间外，人力资源部需记录加班时长或请假时长，作为员工平时表现的一项依据。(2) 临时工每周工作时间不固定，基本工资按小时计算，不同岗位的临时工小时工资不同。 人力资源部只需记录实际工作时间。人力资源部和财务部工作人员可以根据各自的需要对员工数据进行汇总处理，人力资源部负责汇总每周员工工作时间，而财务部负责计算每周员工工资。
* 优点：
* 缺点：
* ts通用代码：
* ts实例代码：
* js通用代码：

## 备忘录模式：
* 定义：：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。
* 解释：该模式又叫快照模式。备忘录模式能记录一个对象的内部状态，当用户后悔时能撤销当前操作，使数据恢复到它原先的状态。
* 场景：
</br>  -- Word、记事本、Photoshop、Eclipse 等软件在编辑时按Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；
</br>  -- IE中的后退键
</br>  -- 数据库事务管理中的回滚操作
</br>  -- 玩游戏时的中间结果存档功能
</br>  -- 数据库与操作系统的备份操作
</br>  -- 棋类游戏中的悔棋功能
* 优点：
* 缺点：
* ts通用代码：
* ts实例代码：
* js通用代码：

## 解释器模式：
* 定义：给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。
* 解释：虽然目前计算机编程语言有好几百种，但有时候我们还是希望能用一些简单的语言来实现一些特定的操作，我们只要向计算机输入一个句子或文件，它就能够按照预先定义的文法规则来对句子或文件进行解释，从而实现相应的功能。我们知道，在实际开发中，这些简单的自定义语言可以基于现有的编程语言来设计，此时可以使用解释器模式来实现自定义语言。
* 场景：
</br>  -- 像C++、Java和C#等语言无法直接解释类似“1+ 2 + 3 – 4 + 1”这样的字符串（如果直接作为数值表达式时可以解释），我们必须自己定义一套文法规则来实现对这些语句的解释，即设计一个自定义语言。
</br>  -- 开发微信小程序时，有时我们想直接使用已有html网页代码生成页面，但小程序并不能解析出html标签，这样我们将不得不根据腾讯自定义标签对页面重新开发一套代码。好在有网友开发出了wxParse解析器（https://github.com/icindy/wxParse），能够自动将html代码转换成相应的小程序代码，省时省力
</br>  -- 从下游接口拿到的json对象，很复杂。我们要把这个json在我们的库里面存一份，但是呢这个json对象中有敏感信息，比如手机号，身份证号等信息，要求把这些敏感值加密存储，取出来的时候再解密。
* 优点：
* 缺点：
* ts通用代码：
* ts实例代码：
* js通用代码：



























